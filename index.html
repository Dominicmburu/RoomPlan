<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Room Scanner</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1000;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .ui-panel {
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            color: white;
            pointer-events: all;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        .top-panel {
            max-width: 400px;
            margin: 0 auto;
            text-align: center;
        }

        .bottom-panel {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 600px;
            margin: 0 auto;
            width: 100%;
        }

        .scan-button {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 4px solid #fff;
            background: #ff4757;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            position: relative;
        }

        .scan-button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(255, 71, 87, 0.5);
        }

        .scan-button.scanning {
            background: #2ed573;
            animation: pulse 1.5s infinite;
        }

        .scan-button.processing {
            background: #ffa502;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(46, 213, 115, 0.7); }
            70% { box-shadow: 0 0 0 20px rgba(46, 213, 115, 0); }
            100% { box-shadow: 0 0 0 0 rgba(46, 213, 115, 0); }
        }

        .stats {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 10px;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
        }

        .progress-bar {
            width: 200px;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4757, #2ed573);
            transition: width 0.3s ease;
            width: 0%;
        }

        .guidance-text {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
        }

        .instruction-text {
            font-size: 14px;
            opacity: 0.8;
            line-height: 1.4;
        }

        .controls {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 15px;
        }

        .control-button {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 25px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .control-button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        .control-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .scan-indicators {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        .scan-ring {
            width: 200px;
            height: 200px;
            border: 3px solid rgba(46, 213, 115, 0.6);
            border-radius: 50%;
            border-top: 3px solid #2ed573;
            animation: spin 2s linear infinite;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .scan-ring.active {
            opacity: 1;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .corner-guides {
            position: absolute;
            width: 40px;
            height: 40px;
            border: 2px solid rgba(255, 255, 255, 0.8);
        }

        .corner-guides.top-left {
            top: 20%;
            left: 20%;
            border-right: none;
            border-bottom: none;
        }

        .corner-guides.top-right {
            top: 20%;
            right: 20%;
            border-left: none;
            border-bottom: none;
        }

        .corner-guides.bottom-left {
            bottom: 20%;
            left: 20%;
            border-right: none;
            border-top: none;
        }

        .corner-guides.bottom-right {
            bottom: 20%;
            right: 20%;
            border-left: none;
            border-top: none;
        }

        #canvas {
            display: block;
            width: 100%;
            height: 100%;
            background: #1a1a1a;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .modal.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background: rgba(20, 20, 20, 0.95);
            backdrop-filter: blur(20px);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            color: white;
            max-width: 500px;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top: 4px solid #2ed573;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        
        <div id="ui-overlay">
            <div class="ui-panel top-panel">
                <div class="guidance-text" id="guidance-text">Point your device at the room</div>
                <div class="instruction-text" id="instruction-text">
                    Move slowly around the room to capture all surfaces. Keep the device steady and ensure good lighting.
                </div>
            </div>

            <div class="ui-panel bottom-panel">
                <div class="stats">
                    <div class="stat-item">
                        <span>📊 Frames:</span>
                        <span id="frame-count">0</span>
                    </div>
                    <div class="stat-item">
                        <span>📡 Quality:</span>
                        <div class="progress-bar">
                            <div class="progress-fill" id="quality-progress"></div>
                        </div>
                    </div>
                    <div class="stat-item">
                        <span>🎯 Coverage:</span>
                        <span id="coverage-percent">0%</span>
                    </div>
                </div>

                <div class="scan-button" id="scan-button">
                    <span id="scan-icon">📷</span>
                </div>

                <div class="controls">
                    <button class="control-button" id="process-button" disabled>
                        Process Scan
                    </button>
                    <button class="control-button" id="reset-button">
                        Reset
                    </button>
                </div>
            </div>
        </div>

        <div class="scan-indicators">
            <div class="scan-ring" id="scan-ring"></div>
        </div>

        <div class="corner-guides top-left"></div>
        <div class="corner-guides top-right"></div>
        <div class="corner-guides bottom-left"></div>
        <div class="corner-guides bottom-right"></div>
    </div>

    <div class="modal" id="processing-modal">
        <div class="modal-content">
            <h2>Processing Your Room Scan</h2>
            <div class="loading-spinner"></div>
            <p id="processing-status">Analyzing captured data...</p>
            <div style="margin-top: 20px;">
                <div class="progress-bar" style="width: 300px; margin: 0 auto;">
                    <div class="progress-fill" id="processing-progress"></div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        class RoomScanner {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.isScanning = false;
                this.sessionId = null;
                this.frameCount = 0;
                this.captureInterval = null;
                this.apiUrl = 'http://localhost:8000/api';
                
                this.init();
                this.setupEventListeners();
            }

            async init() {
                // Initialize Three.js scene
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), alpha: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                
                // Add some basic lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(1, 1, 1);
                this.scene.add(directionalLight);

                // Set up camera
                this.camera.position.z = 5;
                
                // Check for WebXR support
                if ('xr' in navigator) {
                    try {
                        const isSupported = await navigator.xr.isSessionSupported('immersive-ar');
                        if (isSupported) {
                            this.setupWebXR();
                        } else {
                            this.setupFallbackMode();
                        }
                    } catch (e) {
                        this.setupFallbackMode();
                    }
                } else {
                    this.setupFallbackMode();
                }

                // Start render loop
                this.animate();
            }

            setupWebXR() {
                // WebXR AR setup would go here
                console.log('WebXR AR supported - setting up AR session');
                this.setupFallbackMode(); // For now, fallback to regular camera
            }

            setupFallbackMode() {
                console.log('Using fallback camera mode');
                // Add a simple cube to show the scene is working
                const geometry = new THREE.BoxGeometry();
                const material = new THREE.MeshPhongMaterial({ color: 0x00ff00, transparent: true, opacity: 0.3 });
                const cube = new THREE.Mesh(geometry, material);
                this.scene.add(cube);
                
                // Animate the cube for visual feedback
                this.cube = cube;
            }

            setupEventListeners() {
                document.getElementById('scan-button').addEventListener('click', () => this.toggleScanning());
                document.getElementById('process-button').addEventListener('click', () => this.processModel());
                document.getElementById('reset-button').addEventListener('click', () => this.resetScan());
                
                window.addEventListener('resize', () => this.onWindowResize());
            }

            async toggleScanning() {
                if (this.isScanning) {
                    await this.stopScanning();
                } else {
                    await this.startScanning();
                }
            }

            async startScanning() {
                try {
                    // Start new session
                    const response = await fetch(`${this.apiUrl}/scan/start`, {
                        method: 'POST'
                    });
                    
                    if (!response.ok) throw new Error('Failed to start session');
                    
                    const data = await response.json();
                    this.sessionId = data.session_id;
                    
                    this.isScanning = true;
                    this.updateUI();
                    
                    // Start capturing frames
                    this.captureInterval = setInterval(() => this.captureFrame(), 500);
                    
                } catch (error) {
                    console.error('Error starting scan:', error);
                    this.updateGuidanceText('Error starting scan. Please try again.');
                }
            }

            async stopScanning() {
                this.isScanning = false;
                if (this.captureInterval) {
                    clearInterval(this.captureInterval);
                    this.captureInterval = null;
                }
                this.updateUI();
            }

            async captureFrame() {
                if (!this.isScanning || !this.sessionId) return;

                try {
                    // Simulate capturing frame data
                    const frameData = this.generateMockFrameData();
                    
                    const response = await fetch(`${this.apiUrl}/scan/${this.sessionId}/frame`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(frameData)
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        this.frameCount = result.frame_count;
                        this.updateStats();
                    }
                    
                } catch (error) {
                    console.error('Error capturing frame:', error);
                }
            }

            generateMockFrameData() {
                // Generate mock frame data for demonstration
                // In a real implementation, this would capture actual camera/depth data
                
                const canvas = document.createElement('canvas');
                canvas.width = 640;
                canvas.height = 480;
                const ctx = canvas.getContext('2d');
                
                // Create a simple gradient as mock image data
                const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                gradient.addColorStop(0, `hsl(${Math.random() * 360}, 50%, 50%)`);
                gradient.addColorStop(1, `hsl(${Math.random() * 360}, 50%, 30%)`);
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Add some noise to simulate real camera data
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                for (let i = 0; i < imageData.data.length; i += 4) {
                    imageData.data[i] += Math.random() * 50 - 25;     // R
                    imageData.data[i + 1] += Math.random() * 50 - 25; // G
                    imageData.data[i + 2] += Math.random() * 50 - 25; // B
                }
                ctx.putImageData(imageData, 0, 0);
                
                const imageDataUrl = canvas.toDataURL('image/jpeg', 0.8);
                
                // Generate mock depth data
                const depthCanvas = document.createElement('canvas');
                depthCanvas.width = 640;
                depthCanvas.height = 480;
                const depthCtx = depthCanvas.getContext('2d');
                
                // Create depth map with radial gradient
                const depthGradient = depthCtx.createRadialGradient(320, 240, 0, 320, 240, 400);
                depthGradient.addColorStop(0, 'white');
                depthGradient.addColorStop(1, 'black');
                
                depthCtx.fillStyle = depthGradient;
                depthCtx.fillRect(0, 0, depthCanvas.width, depthCanvas.height);
                
                const depthDataUrl = depthCanvas.toDataURL('image/jpeg', 0.8);
                
                // Mock camera parameters
                const time = Date.now() / 1000;
                const radius = 2;
                const angle = time * 0.5;
                
                return {
                    image_data: imageDataUrl,
                    depth_data: depthDataUrl,
                    camera_position: [
                        Math.cos(angle) * radius,
                        Math.sin(time * 0.3) * 0.5,
                        Math.sin(angle) * radius
                    ],
                    camera_rotation: [0, 0, 0, 1], // Identity quaternion
                    timestamp: time,
                    intrinsics: [525.0, 525.0, 320.0, 240.0] // Mock focal length and principal point
                };
            }

            async processModel() {
                if (!this.sessionId || this.frameCount < 3) {
                    this.updateGuidanceText('Need at least 3 frames to process model');
                    return;
                }

                this.showProcessingModal();
                
                try {
                    const response = await fetch(`${this.apiUrl}/scan/${this.sessionId}/process`, {
                        method: 'POST'
                    });
                    
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.detail || 'Processing failed');
                    }
                    
                    const result = await response.json();
                    
                    // Update processing progress
                    this.updateProcessingProgress(100);
                    
                    // Show success and download option
                    setTimeout(() => {
                        this.showProcessingComplete(result);
                    }, 1000);
                    
                } catch (error) {
                    console.error('Processing error:', error);
                    this.hideProcessingModal();
                    this.updateGuidanceText(`Processing failed: ${error.message}`);
                }
            }

            showProcessingModal() {
                const modal = document.getElementById('processing-modal');
                modal.classList.add('active');
                
                let progress = 0;
                const progressInterval = setInterval(() => {
                    progress += Math.random() * 10;
                    if (progress > 90) progress = 90;
                    this.updateProcessingProgress(progress);
                }, 200);
                
                this.progressInterval = progressInterval;
            }

            hideProcessingModal() {
                const modal = document.getElementById('processing-modal');
                modal.classList.remove('active');
                
                if (this.progressInterval) {
                    clearInterval(this.progressInterval);
                    this.progressInterval = null;
                }
            }

            updateProcessingProgress(progress) {
                const progressBar = document.getElementById('processing-progress');
                progressBar.style.width = `${progress}%`;
                
                let status = 'Analyzing captured data...';
                if (progress > 30) status = 'Building 3D point cloud...';
                if (progress > 60) status = 'Creating mesh geometry...';
                if (progress > 80) status = 'Optimizing and segmenting...';
                if (progress >= 100) status = 'Processing complete!';
                
                document.getElementById('processing-status').textContent = status;
            }

            showProcessingComplete(result) {
                const modalContent = document.querySelector('.modal-content');
                modalContent.innerHTML = `
                    <h2>✅ Room Scan Complete!</h2>
                    <div style="margin: 20px 0;">
                        <p><strong>Vertices:</strong> ${result.mesh_vertices.toLocaleString()}</p>
                        <p><strong>Faces:</strong> ${result.mesh_faces.toLocaleString()}</p>
                        <p><strong>Elements detected:</strong> Floor, Walls, Ceiling</p>
                    </div>
                    <button class="control-button" onclick="roomScanner.downloadModel()" style="margin: 10px;">
                        📥 Download 3D Model
                    </button>
                    <button class="control-button" onclick="roomScanner.hideProcessingModal()" style="margin: 10px;">
                        Close
                    </button>
                `;
            }

            async downloadModel() {
                if (!this.sessionId) return;
                
                try {
                    const response = await fetch(`${this.apiUrl}/scan/${this.sessionId}/download`);
                    
                    if (!response.ok) throw new Error('Download failed');
                    
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `room_scan_${this.sessionId}.glb`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    window.URL.revokeObjectURL(url);
                    
                } catch (error) {
                    console.error('Download error:', error);
                }
            }

            async resetScan() {
                if (this.sessionId) {
                    try {
                        await fetch(`${this.apiUrl}/scan/${this.sessionId}`, {
                            method: 'DELETE'
                        });
                    } catch (error) {
                        console.error('Error cleaning up session:', error);
                    }
                }
                
                this.isScanning = false;
                this.sessionId = null;
                this.frameCount = 0;
                
                if (this.captureInterval) {
                    clearInterval(this.captureInterval);
                    this.captureInterval = null;
                }
                
                this.hideProcessingModal();
                this.updateUI();
                this.updateStats();
                this.updateGuidanceText('Point your device at the room');
            }

            updateUI() {
                const scanButton = document.getElementById('scan-button');
                const scanIcon = document.getElementById('scan-icon');
                const scanRing = document.getElementById('scan-ring');
                const processButton = document.getElementById('process-button');
                
                if (this.isScanning) {
                    scanButton.classList.add('scanning');
                    scanIcon.textContent = '⏸️';
                    scanRing.classList.add('active');
                    this.updateGuidanceText('Scanning... Move around the room');
                } else {
                    scanButton.classList.remove('scanning', 'processing');
                    scanIcon.textContent = '📷';
                    scanRing.classList.remove('active');
                    
                    if (this.frameCount > 0) {
                        this.updateGuidanceText('Scan paused. Continue or process results');
                        processButton.disabled = this.frameCount < 3;
                    } else {
                        this.updateGuidanceText('Point your device at the room');
                        processButton.disabled = true;
                    }
                }
            }

            updateStats() {
                document.getElementById('frame-count').textContent = this.frameCount;
                
                // Mock quality calculation
                const quality = Math.min(100, (this.frameCount / 20) * 100);
                document.getElementById('quality-progress').style.width = `${quality}%`;
                
                // Mock coverage calculation
                const coverage = Math.min(100, (this.frameCount / 15) * 100);
                document.getElementById('coverage-percent').textContent = `${Math.round(coverage)}%`;
            }

            updateGuidanceText(text) {
                document.getElementById('guidance-text').textContent = text;
            }

            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Rotate the demo cube if it exists
                if (this.cube) {
                    this.cube.rotation.x += 0.01;
                    this.cube.rotation.y += 0.01;
                }
                
                this.renderer.render(this.scene, this.camera);
            }
        }

        // Initialize the room scanner when page loads
        let roomScanner;
        window.addEventListener('load', () => {
            roomScanner = new RoomScanner();
        });
    </script>
</body>
</html>